#!/usr/bin/env ruby
require 'open3'
require 'pathname'
require 'rbconfig'
require 'tempfile'

require 'bundler/inline'
gemfile do
  source 'https://rubygems.org'
  gem 'docker-api', '~> 2.0'
  gem 'subprocess', '~> 1.5'
end

class DevTool
  MAIN_HELP_BANNER = <<HEREDOC
Execute various commands within the developer environment

Usage:
  dev [COMMAND] [ARGS...]"
  dev -h|--help

Commands:
  compose            Manage containers (default)
  machine            Manage the virtual machine
  update             Update Dash developer environment
  parallels          Use Parallels
  docker_desktop     Use Docker Desktop
  unset_docker_env   Pass through eval to unset docker env vars

Machine subcommands:
  create-cluster
  destroy
  up
  create (overridden)
  stop (overridden)

HEREDOC

  TOP_COMMANDS=%w{compose machine update parallels docker_desktop unset_docker_env}

  DOMAIN = 'test'
  RESOLVER_DIR = Pathname.new("/etc/resolver")
  CONFIG_DIR = Pathname.new("~/.config/dev").expand_path
  SHARED_CONTAINERS_DIR = Pathname.new('/usr/local/shared_containers')

  def initialize(args)
    unless CONFIG_DIR.directory?
      system!("creating #{CONFIG_DIR}", "mkdir", "-p", CONFIG_DIR)
    end


    Bundler.with_clean_env do
      if args.empty?
        help
      elsif TOP_COMMANDS.include?(args[0])
        send(args.shift.to_sym, args)
      else
        send(:compose, args)
      end
    end
  end

  def help
    puts MAIN_HELP_BANNER
  end

  def compose(args)
    if (Pathname.pwd + 'docker-compose.yml').file?
      project_dir = '.'
    else
      project_dir = `git rev-parse --show-toplevel`.chomp
      if $? != 0
        puts 'Warning: unable to automatically detect project dir'
        project_dir = '.'
      end
    end

    Dir.chdir(project_dir) do
      if args.empty?
        puts `docker-compose --help`
      else
        command = args.first

        compose_files = []

        if (Pathname.pwd + 'docker-compose.override.yml').file?
          compose_files.unshift('-f', 'docker-compose.override.yml')
        end

        docker_host =
          CONFIG_DIR.join('docker_host').open('r') do |f|
            f.read
          end

        binary = ['docker-compose']

        case docker_host
        when 'parallels'
          if (Pathname.pwd.join('docker', 'parallels.yml')).file?
            compose_files.unshift('-f', 'docker/parallels.yml')
          end
        when 'docker-desktop'
          if (Pathname.pwd.join('docker', 'docker-desktop.yml')).file?
            compose_files.unshift('-f', 'docker/docker-desktop.yml')
          end

          binary = ['mutagen', 'compose']
        else
          raise 'Unable to detect docker host!'
        end

        if (Pathname.pwd + 'development.yml').file?
          compose_files.unshift('-f', 'development.yml')
        end

        compose_files.unshift('-f', 'docker-compose.yml')

        args.unshift(*compose_files)
        args.unshift(*binary)
        $stdout.sync
        begin
          Subprocess.check_call(
            args,
            stdin: $stdin,
            stdout: $stdout,
            stderr: $stderr
          )

          if command == 'down'
            puts "Removing log volumes"
            # TODO: only try to remove log volumes for the current project
            remove_log_volumes
            # TODO: Auto retry on ERROR: error while removing network: network app_default id <id> has active endpoints
            # TODO: Remove sync volumes for the current project
          end
        rescue Subprocess::NonZeroExit => e
          puts e.message
          exit 1
        rescue Interrupt
          exit 1
        end
      end
    end
  end

  def parallels(args)
    puts "Setting up Parallels"

    puts 'Terminating mutagen sync'
    system!('Terminate mutagen sync', 'mutagen', 'sync', 'terminate', '-a')

    puts "Removing mutagen sync volumes"
    remove_mutagen_sync_volumes

    puts "Saving config"
    CONFIG_DIR.join('docker_host').open('w') do |f|
      f.write('parallels')
    end
  end

  def docker_desktop(args)
    puts "Setting up Docker Desktop"
    @resolver_file = RESOLVER_DIR.join(DOMAIN)
    configure_resolver!

    if ENV['DOCKER_HOST'] ||
        ENV['DOCKER_CERT_PATH'] ||
        ENV['DOCKER_TLS_VERIFY'] ||
        ENV['DOCKER_MACHINE_NAME']
      puts "ERROR: At least one docker env var is set!"
      puts "You can unset them for this terminal session with:"
      puts "eval $(dev unset_docker_env)"
      exit 1
    end

    puts 'Terminating mutagen sync'
    system!('Terminate mutagen sync', 'mutagen', 'sync', 'terminate', '-a')

    puts "Removing mutagen sync volumes"
    remove_mutagen_sync_volumes

    puts "Saving config"
    CONFIG_DIR.join('docker_host').open('w') do |f|
      f.write('docker-desktop')
    end

    puts "Starting shared containers"
    start_shared_containers
  end

  def unset_docker_env(args)
    puts <<~EOS
    unset DOCKER_HOST
    unset DOCKER_CERT_PATH
    unset DOCKER_TLS_VERIFY
    unset DOCKER_MACHINE_NAME
    EOS
  end

  def machine(args)
    if args.empty?
      puts `docker-machine --help`
    elsif args.first == 'env'
      args.shift
      machine_name = 'default'
      unless args.first.nil?
        machine_name = args.first
      end
      if `docker-machine status #{machine_name}` =~ /Running/
        system("docker-machine env #{machine_name}")
      else
        $stderr.puts "#{machine_name} is not running"
      end
    elsif args.first == 'create'
      puts 'Running `dinghy create` (ignoring args)'
      system('sudo ls > /dev/null')
      system('dinghy create')
      unless system("#{root_dir}/docker/provision-dinghy.sh")
        $stderr.puts "Failed to provision!"
        exit 1
      end
      system('dinghy restart')
      system('eval $(dinghy env); docker start dns > /dev/null')
    elsif args.first == 'create-cluster'
      system('sudo ls > /dev/null')
      exec("#{root_dir}/docker/start-cluster.sh")
    elsif args.first == 'up'
      puts 'Running `dinghy up` (ignoring args)'
      system('sudo ls > /dev/null')
      exec('dinghy up')
    elsif args.first == 'stop'
      puts 'Running `dinghy stop` (ignoring args)'
      system('sudo ls > /dev/null')
      exec('dinghy stop')
    elsif args.first == 'destroy'
      puts 'Running `dinghy destroy` (ignoring args)'
      system('sudo ls > /dev/null')
      exec('dinghy destroy')
    else
      args.unshift('docker-machine')
      exec(args.join(' '))
    end
  end

  def update(args)
    system('cd /usr/local/dev-env && git fetch && git reset --hard origin/master') unless args.first == '--no-pull'
    exec("ansible-playbook #{root_dir}/ansible/mac.yml -i 127.0.0.1, -K") if mac?
    exec("ansible-playbook #{root_dir}/ansible/linux.yml -i 127.0.0.1, -K -v") if linux?
  end

  private

  def root_dir
    '/usr/local/dev-env'
  end

  def mac?
    RbConfig::CONFIG['host_os'] =~ /darwin/
  end

  def linux?
    RbConfig::CONFIG['host_os'] =~ /linux/
  end

  # Many thanks to codekitchen/dinghy for the following methods
  def system!(step, *args)
    system(*args.map(&:to_s)) || raise("Error during #{step}")
  end

  def configure_resolver!
    if resolver_configured?
      puts "DNS resolution is correctly configured"
      return
    end

    puts "setting up DNS resolution, this will require sudo"
    unless RESOLVER_DIR.directory?
      system!("creating #{RESOLVER_DIR}", "sudo", "mkdir", "-p", RESOLVER_DIR)
    end
    Tempfile.open('dinghy-dnsmasq') do |f|
      f.write(resolver_contents)
      f.close
      system!("creating #{@resolver_file}", "sudo", "cp", f.path, @resolver_file)
      system!("creating #{@resolver_file}", "sudo", "chmod", "644", @resolver_file)
    end
    system!("restarting mDNSResponder", "sudo", "killall", "mDNSResponder")
  end

  def resolver_configured?
    @resolver_file.exist? && File.read(@resolver_file) == resolver_contents
  end

  def resolver_contents; <<-EOS.gsub(/^    /, '')
    # Generated by dev
    nameserver 127.0.0.1
    port 19322
    EOS
  end

  def remove_mutagen_sync_volumes
    remove_labelled_volumes(label: 'com.outstand.mutagen-sync')
  end

  def remove_log_volumes
    remove_labelled_volumes(label: 'com.outstand.logs')
  end

  def remove_labelled_volumes(label:)
    volumes = []
    Docker::Volume.all.each do |volume|
      volumes << volume if volume.info.dig('Labels', label)
    end

    volumes.each do |volume|
      begin
        volume.remove
      rescue Docker::Error::ConflictError
        puts "#{volume.id}: volume is in use - unable to remove"
      end
    end
  end

  def start_shared_containers
    unless SHARED_CONTAINERS_DIR.directory?
      system!("creating #{SHARED_CONTAINERS_DIR}", "sudo", "mkdir", "-p", SHARED_CONTAINERS_DIR)
      system!("chowning #{SHARED_CONTAINERS_DIR}", "sudo", "chown", "#{ENV['USER']}:admin", SHARED_CONTAINERS_DIR)

      puts 'Cloning shared_containers...'
      system!("cloning shared_containers", "git", "clone", "https://github.com/outstand/shared-containers", SHARED_CONTAINERS_DIR)
    end

    Dir.chdir(SHARED_CONTAINERS_DIR) do
      system!("update shared_containers", "git", "fetch")
      system!("update shared_containers", "git", "reset", "--hard", "origin/master")

      system!("start shared_containers", "docker-compose", "up", "-d")
      system!("start shared_containers", "mutagen", "project", "start")
    end
  end
end

DevTool.new(ARGV) if __FILE__==$0
